package com.keylimetie.dottysimport android.Manifestimport android.app.NotificationChannelimport android.app.NotificationManagerimport android.app.PendingIntentimport android.content.Contextimport android.content.Intentimport android.content.SharedPreferencesimport android.content.pm.PackageManagerimport android.content.pm.PackageManager.PERMISSION_GRANTEDimport android.content.res.Configurationimport android.graphics.drawable.ColorDrawableimport android.location.Locationimport android.os.Buildimport android.os.Bundleimport android.os.Handlerimport android.util.DisplayMetricsimport android.util.Logimport android.view.Viewimport android.view.WindowManagerimport android.view.inputmethod.InputMethodManagerimport android.widget.ImageButtonimport android.widget.ProgressBarimport android.widget.Toastimport androidx.appcompat.app.ActionBarimport androidx.appcompat.app.AlertDialogimport androidx.appcompat.app.AppCompatActivityimport androidx.core.app.ActivityCompatimport androidx.core.app.NotificationCompatimport androidx.core.app.NotificationManagerCompatimport androidx.core.content.ContextCompat.checkSelfPermissionimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.LifecycleObserverimport androidx.lifecycle.OnLifecycleEventimport com.dottysrewards.dottys.service.VolleyServiceimport com.estimote.coresdk.common.config.EstimoteSDKimport com.keylimetie.dottys.beacon_service.DottysBeaconActivityimport com.keylimetie.dottys.beacon_service.DottysBeaconDelegatesimport com.keylimetie.dottys.models.DottysGlobalDataModelimport com.keylimetie.dottys.models.DottysRewardsModelimport com.keylimetie.dottys.splash.DottysSplashActivityimport com.keylimetie.dottys.ui.dashboard.DashboardFragmentimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconArrayimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconsModelimport com.keylimetie.dottys.ui.drawing.DottysDrawingRewardsModelimport com.keylimetie.dottys.ui.locations.DottysLocationStoresObserverimport com.keylimetie.dottys.ui.locations.DottysLocationsMapFragmentimport com.keylimetie.dottys.ui.locations.DottysLocationsStoresModelimport com.keylimetie.dottys.ui.locations.LocationsViewModelimport com.keylimetie.dottys.utils.ForegroundCheckTaskimport com.keylimetie.dottys.utils.TaskBackgroundTimeIntervalimport com.keylimetie.dottys.utils.geofence.DottysGeofenceimport com.onesignal.*import com.onesignal.OneSignal.NotificationReceivedHandlerimport org.json.JSONObjectimport kotlin.properties.Delegatesenum class PreferenceTypeKey {    USER_DATA, REWARDS, GLOBAL_DATA, LOCATIONS, DOTTYS_USER_LOCATION, BEACONS_LIST, BEACON_AT_CONECTION, DRAWINGS}object EstimoteCredentials {    const val APP_ID =        "appsupport-icsdottys-com-s-00i"//dottys-rewards-aa2"// "appsupport-icsdottys-com-s-00i"    const val APP_TOKEN = "3279b08f8557362e2d6bb7901b83ed17" //"d32ab3c4fb178ee04defe33d53ac9932"}@Suppress("DEPRECATED_IDENTITY_EQUALS", "NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS")open class DottysBaseActivity : AppCompatActivity(), DottysBeaconDelegates, OSPermissionObserver,    OSSubscriptionObserver, LifecycleObserver, DottysLocationChangeDelegates,    com.keylimetie.dottys.ui.locations.DottysLocationDelegates {    private var geofenceActivity: DottysGeofence? = null    var backButton: ImageButton? = null    var sharedPreferences: SharedPreferences? = null    var editor: SharedPreferences.Editor? = null    var actionBarView: View? = null    var isUpdatingLocation: Boolean? = null    var baseUrl: String? = null    var progressBar: ProgressBar? = null    val displayMetrics = DisplayMetrics()    var gpsTracker: GpsTracker? = null    var isOnBackground: Boolean? = null    var beaconsStatusObserver: DottysBeaconStatusObserver? = null    var mainNavigationActivity: DottysMainNavigationActivity? = null    var dashboardFragment: DashboardFragment? = null    var taskAtBackground: ForegroundCheckTask? = null   // var geofencesAtStore: DottysGeofenceActivity? = null    var mapFragmentBase: DottysLocationsMapFragment? = null    private var beaconService: DottysBeaconActivity? = null    var locationsBaseViewModel: LocationsViewModel? = null    var lastKnownLatitudeGps = 0.0    var lastKnownLongitudeGps = 0.0    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        VolleyService.initialize(this)        OneSignal.addPermissionObserver(this)        OneSignal.addSubscriptionObserver(this)        // baseUrl = this.resources.getString(R.string.url_base_development)        baseUrl = this.resources.getString(R.string.url_base_production)        progressBar = findViewById(R.id.progress_loader)        //hideLoader(this)        sharedPreferences = this.getSharedPreferences(            PreferenceTypeKey.USER_DATA.name,            Context.MODE_PRIVATE        )        //firebaseAnalytics = Firebase.analytics        println(getUserPreference().token)        // Logging set to help debug issues, remove before releasing your app.        //   OneSignal.setLogLevel(OneSignal.LOG_LEVEL.VERBOSE, OneSignal.LOG_LEVEL.NONE);        // OneSignal Initialization        OneSignal.startInit(this)            .inFocusDisplaying(OneSignal.OSInFocusDisplayOption.Notification)            .unsubscribeWhenNotificationsAreDisabled(true)            .init()        /* TRANSITION ANIM */        overridePendingTransition(            R.anim.slide_in_left, R.anim.slide_out_left        )//        if (savedInstanceState == null) // 1st time//        {//            this.overridePendingTransition(R.anim.slide_in_left,//                R.anim.slide_out_left)//        } else // already created so reverse animation//        {//            this.overridePendingTransition(R.anim.slide_out_left, R.anim.slide_in_left)//            onStartCount = 2//        }        /*BACKGROUND TASK MANAGER*///        ProcessLifecycleOwner.get().lifecycle.addObserver(this)//        gpsTracker = GpsTracker(this)//        gpsTracker?.locationObserver = DottysLocationObserver(this)        /*ADD GEOFENCES*/       //   geofencesAtStore = DottysGeofenceActivity(this, getUserNearsLocations().locations ?: return)//        if (getUserPreference() != null || progressBar?.visibility != 0) {//            if (!(getUserNearsLocations()?.locations.isNullOrEmpty()) &&//                getUserNearsLocations()?.locations?.first()?.distance ?: return < 0.5) {//                initEstimoteBeaconManager(this)//            }//        }    }    private fun initEstimoteBeaconManager(context: DottysBaseActivity) {        if (isProbablyAnEmulator()) {            return        }        beaconService = DottysBeaconActivity(this)        beaconService.let { it?.initBeaconManager() }    }//    override fun startForegroundService(service: Intent?): ComponentName? {//        Log.d("FOREGROUND TASK", "FOREGROUND  -- SERVICE SHOUL BE STARTED")////        return super.startForegroundService(service)//    }    override fun onStart() {        super.onStart()        if (gpsTracker == null) {            gpsTracker = GpsTracker(this)            gpsTracker?.getLocation()            gpsTracker?.locationObserver = DottysLocationObserver(this)        }        EstimoteSDK.initialize(this, EstimoteCredentials.APP_ID, EstimoteCredentials.APP_TOKEN)        if (getUserPreference() != null || progressBar?.visibility != 0) {            if (!(getUserNearsLocations().locations.isNullOrEmpty()) &&                getUserNearsLocations().locations?.first()?.distance ?: return < 0.2            ) {                Handler().postDelayed({                    initEstimoteBeaconManager(this)                }, 1000 * 60 * 5) // 5 minutes            } else {                beaconService?.let { it -> it.beaconManager?.let { it.disconnect() } }            }        }    }    override fun finish() {        super.finish()        overridePendingTransition(            R.anim.slide_out_left, R.anim.slide_out_right        )    }    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)    fun onAppBackgrounded() {        Log.d("FOREGROUND TASK", "** FOREGROUND TASK BACKGROUNG")        if (taskAtBackground == null && isOnBackground == false) {            isOnBackground = true            taskAtBackground = ForegroundCheckTask(true, this)            taskAtBackground?.execute(this)        }    }    @OnLifecycleEvent(Lifecycle.Event.ON_START)    fun onAppForegrounded() {        // ForegroundCheckTask().cancel(true)        Log.d("FOREGROUND TASK", "** FOREGROUND TASK  FOREGROUND")        isOnBackground = false        taskAtBackground?.isOnBackground = false        taskAtBackground?.cancel(true)        taskAtBackground = null    }    override fun onOSPermissionChanged(stateChanges: OSPermissionStateChanges) {        if (stateChanges.from.enabled &&            !stateChanges.to.enabled        ) {            AlertDialog.Builder(this).setMessage("NOtification Disable").show()        }        Log.i("Debug", "onOSPermissionChanged: $stateChanges")    }    override fun onOSSubscriptionChanged(stateChanges: OSSubscriptionStateChanges?) {        if (!(stateChanges?.from?.subscribed ?: return) &&            stateChanges.to?.subscribed ?: return        ) {            AlertDialog.Builder(this)                .setMessage("You've successfully subscribed to push notifications!")                .show()            stateChanges.to.userId        }        Log.i("Debug", "onOSSubscriptionChanged: " + stateChanges)    }    private fun isProbablyAnEmulator() = Build.FINGERPRINT.startsWith("generic")            || Build.FINGERPRINT.startsWith("unknown")            || Build.MODEL.contains("google_sdk")            || Build.MODEL.contains("Emulator")            || Build.MODEL.contains("Android SDK built for x86")            || Build.BOARD == "QC_Reference_Phone" //bluestacks            || Build.MANUFACTURER.contains("Genymotion")            || Build.HOST.startsWith("Build") //MSI App Player            || (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic"))            || "google_sdk" == Build.PRODUCT    fun actionBarSetting(actionBar: ActionBar, coloBackground: ColorDrawable) {        actionBar.displayOptions = ActionBar.DISPLAY_SHOW_CUSTOM        actionBar.setDisplayShowCustomEnabled(true)        actionBar.setCustomView(R.layout.custom_action_bar)        actionBar.elevation = 1F        actionBarView = actionBar.customView        actionBar.setBackgroundDrawable(coloBackground)        backButton = actionBarView?.findViewById<ImageButton>(R.id.back_image_button)        backButton?.setOnClickListener {            finish()        }    }    /**     * SAVE PREFERENCE DATA     * */    fun saveDataPreference(keyPreference: PreferenceTypeKey, jsonData: String) {        editor = sharedPreferences!!.edit()        editor!!.putString(keyPreference.name, jsonData)        editor!!.commit()        when (keyPreference) {            PreferenceTypeKey.BEACON_AT_CONECTION -> {                getBeaconStatus()?.beaconArray.let {                    if (it != null) {                        beaconsStatusObserver?.listOfBeacons = it                    }                }            }            PreferenceTypeKey.LOCATIONS -> {                var beaconData = getDottysBeaconsList() ?: return                val locationData = DottysLocationsStoresModel.fromLocationJson(jsonData)                if (locationData.locations?.first()?.distance ?: 1.0 > 1.5) {                    saveDataPreference(PreferenceTypeKey.BEACON_AT_CONECTION,                        DottysBeaconArray(ArrayList<DottysBeacon>()).toJson())                    return                }                var beaconAtStore =                    beaconData.filter { it.location?.storeNumber ?: 0 == locationData.locations?.first()?.storeNumber ?: 0 }                            as ArrayList                saveDataPreference(PreferenceTypeKey.BEACON_AT_CONECTION,                    DottysBeaconArray(beaconAtStore).toJson())            }            else -> {                return            }        }    }    private fun removeReferenceData(keyPreference: PreferenceTypeKey) {        editor = sharedPreferences!!.edit()        editor!!.remove(keyPreference.name)        editor!!.commit()    }    /**     * REQUEST LOCATION PERMOSION     * */    open fun requestLocation(gpsTracker: GpsTracker?, activity: AppCompatActivity?) {        try {            if (checkSelfPermission(                    applicationContext,                    Manifest.permission.ACCESS_FINE_LOCATION                ) !== PERMISSION_GRANTED            ) {                ActivityCompat.requestPermissions(                    activity!!,                    arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),                    101                )            }        } catch (e: java.lang.Exception) {            e.printStackTrace()        }//        gpsTracker?.let { activity?.let { it1 -> getLocation(it, it1) } }    }    // GET BEACON FOR CURRENT STORE    fun getDottysBeaconsList(): ArrayList<DottysBeacon>? {        val textoDate = sharedPreferences!!.getString(PreferenceTypeKey.BEACONS_LIST.name, "")        return try {            var person: DottysBeaconsModel =                DottysBeaconsModel.fromJson(                    textoDate!!                )            try {                var beaconAtStore =                    person.beacons//.beacons?.filter { it.location?.storeNumber ?: 0 == getUserNearsLocations().locations?.first()?.storeNumber ?: 0 }                            as ArrayList                //saveDataPreference(PreferenceTypeKey.BEACON_AT_CONECTION,                //    DottysBeaconArray(beaconAtStore).toJson())                beaconAtStore            } catch (e: Exception) {                println(e)                null            }        } catch (e: Exception) {            println(e)            null        }    }    fun getBeaconStatus(): DottysBeaconArray? {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.USER_DATA.name,                Context.MODE_PRIVATE            )        }        val textoDate =            sharedPreferences!!.getString(PreferenceTypeKey.BEACON_AT_CONECTION.name, "")        return try {            var person: DottysBeaconArray? =                textoDate?.let { DottysBeaconArray.fromJson(it) }            person        } catch (e: Exception) {            println(e)            null        }    }    fun getUserPreference(): DottysLoginResponseModel {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.USER_DATA.name,                Context.MODE_PRIVATE            )        }        val userData = sharedPreferences!!.getString(PreferenceTypeKey.USER_DATA.name, "")        return try {            var currentUserData: DottysLoginResponseModel =                DottysLoginResponseModel.fromJson(                    userData!!                )            currentUserData        } catch (e: Exception) {            println(e)            DottysLoginResponseModel()        }    }    fun getGlobalData(): DottysGlobalDataModel {        val globalInfo = sharedPreferences!!.getString(PreferenceTypeKey.GLOBAL_DATA.name, "")        return try {            var globalData: DottysGlobalDataModel =                DottysGlobalDataModel.fromJson(                    globalInfo!!                )            globalData        } catch (e: Exception) {            println(e)            DottysGlobalDataModel()        }    }    fun getDrawings(): DottysDrawingRewardsModel {        val drawingData = sharedPreferences!!.getString(PreferenceTypeKey.GLOBAL_DATA.name, "")        return try {            var drawingLocations: DottysDrawingRewardsModel =                DottysDrawingRewardsModel.fromJson(                    drawingData!!                )            drawingLocations        } catch (e: Exception) {            println(e)            DottysDrawingRewardsModel()        }    }    // GET ALL DOTTYS LOCATIONS    fun getUserNearsLocations(): DottysLocationsStoresModel {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.USER_DATA.name,                Context.MODE_PRIVATE            )        }        val nearStoreData = sharedPreferences?.getString(PreferenceTypeKey.LOCATIONS.name, "")        return try {            var nearStoreLocation: DottysLocationsStoresModel =                DottysLocationsStoresModel.fromLocationJson(                    nearStoreData!!                )            nearStoreLocation        } catch (e: Exception) {            println(e)            DottysLocationsStoresModel()        }    }    fun getRewardsAtSession(): DottysRewardsModel {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.DRAWINGS.name,                Context.MODE_PRIVATE            )        }        val rewardsDAta = sharedPreferences!!.getString(PreferenceTypeKey.USER_DATA.name, "")        return try {            var rewards: DottysRewardsModel =                DottysRewardsModel.fromJson(                    rewardsDAta!!                )            rewards        } catch (e: Exception) {            println(e)            DottysRewardsModel()        }    }    fun showLoader() {        if (progressBar?.visibility == View.VISIBLE) {            return        }        progressBar = this.findViewById<ProgressBar>(R.id.progress_loader)        progressBar?.visibility = View.VISIBLE        window.setFlags(            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE        )    }    fun hideLoader() {//        if (progressBar?.visibility == null){//            return }        progressBar = this.findViewById<ProgressBar>(R.id.progress_loader)        progressBar?.visibility = View.INVISIBLE        window.clearFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE)    }    fun finishSession(mContext: DottysBaseActivity) {        // Toast.makeText(mContext, "User Logout", Toast.LENGTH_LONG).show()        val editPref = mContext.sharedPreferences?.edit()        editPref?.clear()        editPref?.apply()        mContext.removeReferenceData(PreferenceTypeKey.USER_DATA)        editPref?.commit()        mContext.sharedPreferences = null        val intent = Intent(mContext, DottysSplashActivity::class.java)        ///**/ intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)        mContext.startActivity(intent)        // mContext.finish()    }    fun setBackButton() {        backButton = actionBarView?.findViewById<ImageButton>(R.id.back_image_button)        backButton?.setImageResource(R.drawable.back_icon_black)        backButton?.scaleY = 0.5f        backButton?.scaleX = 0.5f    }    override fun onConfigurationChanged(newConfig: Configuration) {        super.onConfigurationChanged(newConfig)        // Checks whether a hardware keyboard is available        if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) {            Toast.makeText(this, "keyboard visible", Toast.LENGTH_SHORT).show()        } else if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {            Toast.makeText(this, "keyboard hidden", Toast.LENGTH_SHORT).show()        }    }    fun hideCustomKeyboard() {        val imm: InputMethodManager =            getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        imm.hideSoftInputFromWindow(window.decorView.rootView.windowToken, 0)        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN)    }    override fun getBeaconRecorded(beaconRecorded: DottysBeacon) {        var beaconAux = beaconRecorded        // var observer =  DottysBeaconActivityObserver(mainNavActivity ?: DashboardFragment())        var beaconsTemp = ArrayList<DottysBeacon>()        if (getBeaconStatus()?.beaconArray?.size ?: 0 > 0) {            beaconsTemp = (getBeaconStatus()!!).beaconArray ?: ArrayList<DottysBeacon>()        }//        else {//            beaconsTemp =  DottysBeaconArray(getBeaconStatus()).beaconArray ?: ArrayList<DottysBeacon>()//        }        var beaconsTemp2 = beaconsTemp        for (x in 0 until beaconsTemp.size) {            if (beaconsTemp[x].id == beaconRecorded.beaconIdentifier ||                beaconsTemp[x].beaconIdentifier == beaconRecorded.beaconIdentifier            ) {                beaconAux.isConected = beaconRecorded.eventType?.equals("ENTER") == true                beaconsTemp2[x] = beaconAux            } else {                beaconsTemp2[x] = beaconsTemp[x]            }        }//                for ((index,beacon) in beaconsTemp.withIndex()) if (beacon.id == beaconRecorded.beaconIdentifier) {//                    if(beaconRecorded.eventType?.equals("ENTER") == true) {//                            beaconRecorded.isConected = true//                        } else {//                        beaconRecorded.isConected = false//                    }//                    beaconsTemp2[index] = beaconRecorded////                }        // observer.listOfBeacons = DottysBeaconArray(beaconsTemp2)        dashboardFragment?.dashboardViewModel?.initAnalitycsItems(DottysBeaconArray(beaconsTemp2).beaconArray)        Toast.makeText(            this,            "Has ${beaconRecorded.eventType} to ${beaconRecorded.beaconType} Beacon",            Toast.LENGTH_LONG        ).show()    }    //    override fun onLocationChangeHandler(locationGps: Location?) {        Log.d("LOCATION CHANGE",            "**  BASE ACTIVITY ${locationGps?.latitude} //  ${locationGps?.longitude}")//       if (geofenceActivity == null) {//           geofenceActivity = DottysGeofence(this)//       }        if (locationsBaseViewModel == null) {            locationsBaseViewModel = LocationsViewModel(this)        }        locationsBaseViewModel?.getLocationsDottysRequest(this,            locationGps?.latitude.toString(),            locationGps?.longitude.toString())        locationsBaseViewModel?.locationDataObserver = DottysLocationStoresObserver(this)        if (mapFragmentBase != null) {            mapFragmentBase?.updateMarker()            val fragmentActivity =                locationsBaseViewModel?.locationFragment?.activity as DottysMainNavigationActivity            locationsBaseViewModel?.initLocationView(locationsBaseViewModel?.locationFragment                ?: return, fragmentActivity, locationsBaseViewModel?.rootView ?: return)            // locationsViewModel.initMapWHitMarker(getUserNearsLocations().locations ?: return)        }    }    override fun getStoresLocation(locations: DottysLocationsStoresModel) {        editor = sharedPreferences!!.edit()        if (locations.locations.isNullOrEmpty()) {            return        }        val distance = locations.locations?.first()?.distance ?: return        dashboardFragment?.dashboardViewModel?.initAnalitycsItems(getBeaconStatus()?.beaconArray)       // HuntMainActivity(this)     //  geofenceActivity = DottysGeofences(this)        //TODO SHOULD BE START BEACONS AT STORES SCANING        //if (distance > 0.2) { //geofencesAtStore ==  null &&            //geofencesAtStore =             //   DottysGeofenceActivity(this, getUserNearsLocations().locations ?: return)       //}//        taskAtBackground?.updateLocationInterval = intervalAtDistance(distance)//        taskAtBackground?.triggerBackgroundTask()    }    override fun allItemsCollapse(isColappse: Boolean) {}    private fun intervalAtDistance(distance: Double): TaskBackgroundTimeInterval {        return when {            distance <= 0.03 -> {                TaskBackgroundTimeInterval.ZERO_INTERVAL            }            distance <= 0.1 -> {                TaskBackgroundTimeInterval.SMALL_INTERVAL            }            distance <= 2.0 -> {                TaskBackgroundTimeInterval.MEDIUM_INTERVAL            }            else -> {                TaskBackgroundTimeInterval.LONG_INTERVAL            }        }    }}/* BASE DELEGATES*/interface DottysBeaconStatusDelegate {    fun onBeaconsChange(beaconsData: ArrayList<DottysBeacon>)    fun onDistanceToStoreChange(distance: Double)}class DottysBeaconStatusObserver(lisener: DottysBeaconStatusDelegate) {    var listOfBeacons: ArrayList<DottysBeacon> by Delegates.observable(        initialValue = ArrayList<DottysBeacon>(),        onChange = { _, _, new -> lisener.onBeaconsChange(new) })    var distanceToNearStore: Double by Delegates.observable(        initialValue = (999999.0).toDouble(),        onChange = { _, _, new -> lisener.onDistanceToStoreChange(new) })}internal class ExampleNotificationReceivedHandler : NotificationReceivedHandler {    override fun notificationReceived(notification: OSNotification) {        val data: JSONObject = notification.payload.additionalData        val customKey: String        if (data != null) {            customKey = data.optString("customkey", null)            if (customKey != null) Log.i(                "OneSignalExample",                "customkey set with value: $customKey"            )        }    }}