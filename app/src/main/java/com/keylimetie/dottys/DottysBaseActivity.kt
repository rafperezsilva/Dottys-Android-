package com.keylimetie.dottysimport android.Manifestimport android.content.Contextimport android.content.Intentimport android.content.SharedPreferencesimport android.content.pm.PackageManager.PERMISSION_GRANTEDimport android.content.res.Configurationimport android.graphics.drawable.ColorDrawableimport android.os.Buildimport android.os.Bundleimport android.util.DisplayMetricsimport android.view.Viewimport android.view.WindowManagerimport android.view.inputmethod.InputMethodManagerimport android.widget.*import androidx.appcompat.app.ActionBarimport androidx.appcompat.app.AppCompatActivityimport androidx.core.app.ActivityCompatimport androidx.core.content.ContextCompat.checkSelfPermissionimport com.dottysrewards.dottys.service.VolleyServiceimport com.estimote.sdk.EstimoteSDKimport com.estimote.sdk.SystemRequirementsCheckerimport com.google.firebase.analytics.FirebaseAnalyticsimport com.google.firebase.analytics.ktx.analyticsimport com.google.firebase.ktx.Firebaseimport com.keylimetie.dottys.beacon_service.DottysBeaconActivityimport com.keylimetie.dottys.beacon_service.DottysBeaconActivityObserverimport com.keylimetie.dottys.beacon_service.DottysBeaconDelegatesimport com.keylimetie.dottys.login.DottysLoginActivityimport com.keylimetie.dottys.models.DottysGlobalDataModelimport com.keylimetie.dottys.models.DottysRewardsModelimport com.keylimetie.dottys.register.DottysRegisterActivityimport com.keylimetie.dottys.splash.DottysSplashActivityimport com.keylimetie.dottys.ui.dashboard.DashboardFragmentimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconArrayimport com.keylimetie.dottys.ui.dashboard.models.DottysBeaconsModelimport com.keylimetie.dottys.ui.drawing.DottysDrawingRewardsModelimport com.keylimetie.dottys.ui.locations.DottysLocationsStoresModelimport com.onesignal.OneSignalimport kotlin.collections.ArrayListimport kotlin.properties.Delegatesenum class PreferenceTypeKey {    USER_DATA, REWARDS, GLOBAL_DATA, LOCATIONS, DOTTYS_USER_LOCATION, BEACON_AT_LOCATION, BEACON_AT_CONECTION, DRAWINGS}@Suppress("DEPRECATED_IDENTITY_EQUALS", "NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS")open class DottysBaseActivity : AppCompatActivity(), DottysBeaconDelegates {    var backButton: ImageButton? = null    var sharedPreferences: SharedPreferences? = null    var editor: SharedPreferences.Editor? = null    var actionBarView: View? = null    var baseUrl: String? = null    var progressBar: ProgressBar? = null    val displayMetrics = DisplayMetrics()    var gpsTracker: GpsTracker? = null    private lateinit var firebaseAnalytics: FirebaseAnalytics    var beaconsStatusObserver: DottysBeaconStatusObserver? = null    var mainNavActivity: DashboardFragment? = null    companion object {        const val APP_ID = "appsupport-icsdottys-com-s-00i"        val APP_TOKEN = "3279b08f8557362e2d6bb7901b83ed17"    }    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        VolleyService.initialize(this)        baseUrl = this.resources.getString(R.string.url_base_development)        //baseUrl = this.resources.getString(R.string.url_base_production)        progressBar = findViewById(R.id.progress_loader)        //hideLoader(this)        sharedPreferences = this.getSharedPreferences(PreferenceTypeKey.USER_DATA.name, Context.MODE_PRIVATE)        firebaseAnalytics = Firebase.analytics        println(getUserPreference().token)        // OneSignal Initialization        OneSignal.startInit(this)            .inFocusDisplaying(OneSignal.OSInFocusDisplayOption.Notification)            .unsubscribeWhenNotificationsAreDisabled(true)            .init()        overridePendingTransition(            R.anim.slide_in_left, R.anim.slide_out_left        )//        if (savedInstanceState == null) // 1st time//        {//            this.overridePendingTransition(R.anim.slide_in_left,//                R.anim.slide_out_left)//        } else // already created so reverse animation//        {//            this.overridePendingTransition(R.anim.slide_out_left, R.anim.slide_in_left)//            onStartCount = 2//        }    }    override fun finish() {        super.finish()        overridePendingTransition(            R.anim.slide_out_left, R.anim.slide_out_right        )    }    override fun onResume() {        super.onResume()        SystemRequirementsChecker.checkWithDefaultDialogs(this)    }    fun initEstimoteBeaconManager(context: DashboardFragment) {        if (isProbablyAnEmulator()) {            return        }        EstimoteSDK.initialize(applicationContext, APP_ID, APP_TOKEN)        EstimoteSDK.enableDebugLogging(true)        val beaconService = DottysBeaconActivity(this)        mainNavActivity = context        beaconService.initBeaconManager()    }    private fun isProbablyAnEmulator() = Build.FINGERPRINT.startsWith("generic")            || Build.FINGERPRINT.startsWith("unknown")            || Build.MODEL.contains("google_sdk")            || Build.MODEL.contains("Emulator")            || Build.MODEL.contains("Android SDK built for x86")            || Build.BOARD == "QC_Reference_Phone" //bluestacks            || Build.MANUFACTURER.contains("Genymotion")            || Build.HOST.startsWith("Build") //MSI App Player            || (Build.BRAND.startsWith("generic") && Build.DEVICE.startsWith("generic"))            || "google_sdk" == Build.PRODUCT    fun actionBarSetting(actionBar: ActionBar, coloBackground: ColorDrawable) {        actionBar.displayOptions = ActionBar.DISPLAY_SHOW_CUSTOM        actionBar.setDisplayShowCustomEnabled(true)        actionBar.setCustomView(R.layout.custom_action_bar)        actionBar.elevation = 1F        actionBarView = actionBar.customView        actionBar.setBackgroundDrawable(coloBackground)        backButton = actionBarView?.findViewById<ImageButton>(R.id.back_image_button)        backButton?.setOnClickListener {            finish()        }    }    fun saveDataPreference(keyPreference: PreferenceTypeKey, jsonData: String) {        editor = sharedPreferences!!.edit()        editor!!.putString(keyPreference.name, jsonData)        editor!!.commit()        when (keyPreference) {            PreferenceTypeKey.BEACON_AT_CONECTION -> {                getBeaconStatus()?.beaconArray.let {                    if (it != null) {                        beaconsStatusObserver?.listOfBeacons = it                    }                }            }            else -> {                return            }        }    }    private fun removeReferenceData(keyPreference: PreferenceTypeKey) {        editor = sharedPreferences!!.edit()        editor!!.remove(keyPreference.name)        editor!!.commit()    }    open fun requestLocation(gpsTracker: GpsTracker?, activity: AppCompatActivity?) {        try {            if (checkSelfPermission(                    applicationContext,                    Manifest.permission.ACCESS_FINE_LOCATION                ) !== PERMISSION_GRANTED            ) {                ActivityCompat.requestPermissions(                    activity!!,                    arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),                    101                )            }        } catch (e: java.lang.Exception) {            e.printStackTrace()        }//        gpsTracker?.let { activity?.let { it1 -> getLocation(it, it1) } }    }    fun getBeaconAtStoreLocation(): ArrayList<DottysBeacon>? {        val textoDate = sharedPreferences!!.getString(PreferenceTypeKey.BEACON_AT_LOCATION.name, "")        return try {            var person: DottysBeaconsModel =                DottysBeaconsModel.fromJson(                    textoDate!!                )            try {                var beaconAtStore =                    person.beacons?.filter { it.location?.storeNumber ?: 0 == getUserNearsLocations().locations?.first()?.storeNumber ?: 0 }                            as ArrayList                beaconAtStore            } catch (e: Exception) {                println(e)                null            }        } catch (e: Exception) {            println(e)            null        }    }    fun getBeaconStatus(): DottysBeaconArray? {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.USER_DATA.name,                Context.MODE_PRIVATE            )        }        val textoDate =            sharedPreferences!!.getString(PreferenceTypeKey.BEACON_AT_CONECTION.name, "")        return try {            var person: DottysBeaconArray? =                textoDate?.let { DottysBeaconArray.fromJson(it) }            person        } catch (e: Exception) {            println(e)            null        }    }    fun getUserPreference(): DottysLoginResponseModel {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.USER_DATA.name,                Context.MODE_PRIVATE            )        }        val userData = sharedPreferences!!.getString(PreferenceTypeKey.USER_DATA.name, "")        return try {            var currentUserData: DottysLoginResponseModel =                DottysLoginResponseModel.fromJson(                    userData!!                )            currentUserData        } catch (e: Exception) {            println(e)            DottysLoginResponseModel()        }    }    fun getGlobalData(): DottysGlobalDataModel {        val globalInfo = sharedPreferences!!.getString(PreferenceTypeKey.GLOBAL_DATA.name, "")        return try {            var globalData: DottysGlobalDataModel =                DottysGlobalDataModel.fromJson(                    globalInfo!!                )            globalData        } catch (e: Exception) {            println(e)            DottysGlobalDataModel()        }    }    fun getDrawings(): DottysDrawingRewardsModel {        val drawingData = sharedPreferences!!.getString(PreferenceTypeKey.GLOBAL_DATA.name, "")        return try {            var drawingLocations: DottysDrawingRewardsModel =                DottysDrawingRewardsModel.fromJson(                    drawingData!!                )            drawingLocations        } catch (e: Exception) {            println(e)            DottysDrawingRewardsModel()        }    }    fun getUserNearsLocations(): DottysLocationsStoresModel {        val nearStoreData = sharedPreferences!!.getString(PreferenceTypeKey.LOCATIONS.name, "")        return try {            var nearStoreLocation: DottysLocationsStoresModel =                DottysLocationsStoresModel.fromLocationJson(                    nearStoreData!!                )            nearStoreLocation        } catch (e: Exception) {            println(e)            DottysLocationsStoresModel()        }    }    fun getRewardsAtSession(): DottysRewardsModel {        if (sharedPreferences == null) {            sharedPreferences = this.getSharedPreferences(                PreferenceTypeKey.DRAWINGS.name,                Context.MODE_PRIVATE            )        }        val rewardsDAta = sharedPreferences!!.getString(PreferenceTypeKey.USER_DATA.name, "")        return try {            var rewards: DottysRewardsModel =                DottysRewardsModel.fromJson(                    rewardsDAta!!                )            rewards        } catch (e: Exception) {            println(e)            DottysRewardsModel()        }    }        fun showLoader() {        if (progressBar?.visibility == View.VISIBLE) {            return        }        progressBar = this.findViewById<ProgressBar>(R.id.progress_loader)        progressBar?.visibility = View.VISIBLE        window.setFlags(            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE,            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE        )    }    fun hideLoader() {//        if (progressBar?.visibility == null){//            return }        progressBar = this.findViewById<ProgressBar>(R.id.progress_loader)        progressBar?.visibility = View.INVISIBLE        window.clearFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE)    }    fun finishSession(mContext: DottysBaseActivity) {        // Toast.makeText(mContext, "User Logout", Toast.LENGTH_LONG).show()        val editPref = mContext.sharedPreferences?.edit()        editPref?.clear()        editPref?.apply()        mContext.removeReferenceData(PreferenceTypeKey.USER_DATA)        editPref?.commit()        mContext.sharedPreferences = null        val intent = Intent(mContext, DottysSplashActivity::class.java)        ///**/ intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)        mContext.startActivity(intent)        // mContext.finish()    }    fun setBackButton() {    backButton = actionBarView?.findViewById<ImageButton>(R.id.back_image_button)        backButton?.setImageResource(R.drawable.back_icon_black)        backButton?.scaleY = 0.5f        backButton?.scaleX = 0.5f    }    /*    * LOCATIONS PERMISSIONS    * */    override fun onConfigurationChanged(newConfig: Configuration) {        super.onConfigurationChanged(newConfig)        // Checks whether a hardware keyboard is available        if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) {            Toast.makeText(this, "keyboard visible", Toast.LENGTH_SHORT).show()        } else if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {            Toast.makeText(this, "keyboard hidden", Toast.LENGTH_SHORT).show()        }    }    fun hideCustomKeyboard() {        val imm: InputMethodManager =            getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        imm.hideSoftInputFromWindow(window.decorView.rootView.windowToken, 0)        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN)    }//    fun isValidEmail(target: CharSequence?): Boolean {//        return !TextUtils.isEmpty(target) && Patterns.EMAIL_ADDRESS.matcher(target)//            .matches()//    }    override fun getBeaconRecorded(beaconRecorded: DottysBeacon) {        var beaconAux = beaconRecorded        var observer =  DottysBeaconActivityObserver(mainNavActivity ?: DashboardFragment())        var beaconsTemp = ArrayList<DottysBeacon>()        if (getBeaconStatus()?.beaconArray?.size ?: 0 > 0) {            beaconsTemp = (getBeaconStatus()!!).beaconArray ?: ArrayList<DottysBeacon>()        } else {            beaconsTemp =  DottysBeaconArray(getBeaconAtStoreLocation()).beaconArray ?: ArrayList<DottysBeacon>()        }        var beaconsTemp2 = beaconsTemp        for (x in 0 until beaconsTemp.size){            if (beaconsTemp[x].id == beaconRecorded.beaconIdentifier ||                beaconsTemp[x].beaconIdentifier == beaconRecorded.beaconIdentifier){                beaconAux.isConected = beaconRecorded.eventType?.equals("ENTER") == true                beaconsTemp2[x] = beaconAux            } else {                beaconsTemp2[x] = beaconsTemp[x]            }        }//                for ((index,beacon) in beaconsTemp.withIndex()) if (beacon.id == beaconRecorded.beaconIdentifier) {//                    if(beaconRecorded.eventType?.equals("ENTER") == true) {//                            beaconRecorded.isConected = true//                        } else {//                        beaconRecorded.isConected = false//                    }//                    beaconsTemp2[index] = beaconRecorded////                }        observer.listOfBeacons = DottysBeaconArray(beaconsTemp2)        Toast.makeText(this, "Has ${beaconRecorded.eventType} to ${beaconRecorded.beaconType} Beacon",Toast.LENGTH_LONG).show()    }}/* BASE DELEGATES*/interface DottysBeaconStatusDelegate {    fun onBeaconsChange(beaconsData: ArrayList<DottysBeacon>)}class DottysBeaconStatusObserver(lisener: DottysBeaconStatusDelegate) {    var listOfBeacons: ArrayList<DottysBeacon> by Delegates.observable(        initialValue = ArrayList<DottysBeacon>(),        onChange = { _, _, new -> lisener.onBeaconsChange(new) })}